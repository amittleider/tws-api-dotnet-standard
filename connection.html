<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>TWS API v9.72+: Connection</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="https://www.interactivebrokers.com/favicon.ico" rel="shortcut icon">
<script>
$(document).ready(function(){
		var picked=getCookie("picked");
		if (picked != "") {
			if (!$(this).hasClass("active")) {
				var tabNum = $(this).index();
				var nthChild = picked;
				$("ul#tabs li.active").removeClass("active");
				$(this).addClass("active");
				$("ul#tab li.active").removeClass("active");
				$("ul#tab li:nth-child("+nthChild+")").addClass("active");
				$("ul#tabs li:nth-child("+nthChild+")").addClass("active");
				setCookie("picked", nthChild, 1);
			}
		}
		$("ul#tabs li").click(function(e){
			if (!$(this).hasClass("active")) {
			var tabNum = $(this).index();
			var nthChild = tabNum+1;
			$("ul#tabs li.active").removeClass("active");
			$(this).addClass("active");
			$("ul#tab li.active").removeClass("active");
			$("ul#tab li:nth-child("+nthChild+")").addClass("active");
			setCookie("picked", nthChild, 1);
		}
    });
});
function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays*24*60*60*1000));
    var expires = "expires="+d.toUTCString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
} 
function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0)==' ') c = c.substring(1);
        if (c.indexOf(name) == 0) return c.substring(name.length,c.length);
    }
    return "";
} 
function checkCookie() {
    var picked=getCookie("picked");
    if (picked != "") {
        alert("Welcome again " + picked);
    }else{
        //username = prompt("Please enter your name:", "");
        if (picked != "" && picked != null) {
            setCookie("picked", 1, 365);
        }
    }
}
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ib_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea" style="background-color:black;">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="nav_iblogo.png"/></a></td>
  <td style="padding: 0 0 0 1em;">
   <ul id="tabs"><li class="active">C#</li><li>Java</li><li>VB</li><li>C++</li><li>Python</li></ul>
  </td>
  <td><a href="https://www.interactivebrokers.com/en/index.php?f=customerService&p=email" style="color:#C7C7C7;font-weight:bold;padding: 0 0 0 1em;">Contact us</a></td>
  <!--BEGIN GCS_SEARCHBOX-->
  <td style="position: absolute; right: 0;">
   <div id="google-custom-search" align="right" style="vertical-align: top;">
   <script>
  (function() {
    var cx = '002885114636493240026:q6smajphkxq';
	var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
	</script>
	<gcse:search newWindow="false" enableHistory="true"></gcse:search>
   </div>
   </td>
  <!--END !GCS_SEARCHBOX-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('connection.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Connection </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A TCP connection between the API client application and TWS needs to first be established via the <a class="el" href="classIBApi_1_1EClientSocket.html#a315a7f7a34afc504d84c4f0ca462d924">IBApi.EClientSocket.eConnect</a> function. TWS acts as a server to receive requests from the API application (the client) and responds by taking appropriate actions. The first step is for the API client to initiate a connection to the socket port on which TWS is listening. It is possible to have multiple TWS instances running on the same computer if each is configured with a different API socket port number. Also, each TWS session can receive up to <b>32 different client applications</b> simultaneously. The <b>client ID</b> field specified in the API connection is used to distinguish different API clients.</p>
<h1><a class="anchor" id="connect"></a>
Establishing an API connection</h1>
<p>Once our two main objects have been created, EWrapper and ESocketClient, the client application can connect via the <a class="el" href="classIBApi_1_1EClientSocket.html">IBApi.EClientSocket</a> object:</p>
<ul id="tab">
<li class="active">
<div class="fragment"><div class="line">            clientSocket.eConnect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7497, 0);</div></div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        m_client.eConnect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7497, 0);</div></div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        socketClient.eConnect(&quot;127.0.0.1&quot;, 7497, 0)</div></div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span> bRes = m_pClient-&gt;eConnect( host, port, clientId, m_extraAuth);</div></div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        app.connect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, args.port, clientId=0)</div><div class="line">        print(<span class="stringliteral">&quot;serverVersion:%s connectionTime:%s&quot;</span> % (app.serverVersion(),</div><div class="line">                                                      app.twsConnectionTime()))</div></div><!-- fragment -->  </li>
</ul>
<p>eConnect starts by requesting from the OS that a TCP socket be opened to the specified IP address and host number- the first two parameters in the function call. If the socket cannot be opened, the OS returns an error condition which the API returns as error code 502 to <a class="el" href="interfaceIBApi_1_1EWrapper.html#a7dfc221702ca65195609213c984729b8" title="Handles errors generated within the API itself. If an exception is thrown within the API code it will...">IBApi.EWrapper.error</a>. Since this error is not generated by TWS it is not captured in TWS log files. Most commonly error 502 will indicate that TWS is not running with the API enabled or is listening for connection requests on a different socket port. If connecting across a network, it can also occur if there is a firewall or antivirus program blocking connections.</p>
<p>After the socket has been opened, both applications need to exchange essential information for the API session. First, the version numbers of the client (API program) and server (TWS) are exchanged so that the server and client each know the function calls supported by one another. In this way backwards compatibility can be maintained between TWS and previous API versions. Next TWS will always return certain information for the client session, namely the accounts which are accessible by the TWS session, the next valid order identifier (ID), and the time of connection. In the most common mode of operation the EClient.AsyncEConnect field is set to false and the initial handshake is taken to completion immediately after the socket connection is established. TWS will then immediately provides the API client with this information.</p>
<ul>
<li>Important: The <b>IBApi.EWrapper.nextValidID</b> callback is commonly used to indicate that the connection is completed and other messages can be sent from the API client to TWS. There is the possibility that function calls made prior to this time could be dropped by TWS.</li>
</ul>
<p>There is also an alternative mode of connection used in special cases in wich the variable AsyncEconnect is set to true, and the call to startAPI is only called from the connectAck() function. All IB samples use the mode AsyncEconnect = False.</p>
<h1><a class="anchor" id="ereader"></a>
The EReader Thread</h1>
<p>API programs always have at least two threads of execution. One thread is used for sending messages to TWS, and another thread is used for reading returned messages. The second thread uses the API EReader class to read from the socket and add messages to a queue. Everytime a new message is added to the message queue, a notification flag is triggered to let other threads now that there is a message waiting to be processed. In the two-thread design of an API program, the message queue is also processed by the first thread. In a three-thread design, an additional thread is created to perform this task. The thread responsible for the message queue will decode messages and invoke the appropriate functions in EWrapper. The two-threaded design is used in the IB Python sample Program.py and the C++ sample TestCppClient, while the 'Testbed' samples in the other languages use a three-threaded design. Commonly in a Python asynchronous network application, the <a href="https://docs.python.org/3/library/asyncio.ht" target="_blank">asyncio module</a> will be used to create a more sequential looking code design.</p>
<p>The class which has functionality for reading and parsing raw messages from TWS is the <a class="el" href="classIBApi_1_1EReader.html">IBApi.EReader</a> class.</p>
<ul id="tab">
<li class="active">
<div class="fragment"><div class="line">            <span class="comment">//Create a reader to consume messages from the TWS. The EReader will consume the incoming messages and put them in a queue</span></div><div class="line">            var reader = <span class="keyword">new</span> EReader(clientSocket, readerSignal);</div><div class="line">            reader.Start();</div><div class="line">            <span class="comment">//Once the messages are in the queue, an additional thread can be created to fetch them</span></div><div class="line">            <span class="keyword">new</span> Thread(() =&gt; { <span class="keywordflow">while</span> (clientSocket.IsConnected()) { readerSignal.waitForSignal(); reader.processMsgs(); } }) { IsBackground = <span class="keyword">true</span> }.Start();</div></div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        <span class="keyword">final</span> EReader reader = <span class="keyword">new</span> EReader(m_client, m_signal);   </div><div class="line">        </div><div class="line">        reader.start();</div><div class="line">        <span class="comment">//An additional thread is created in this program design to empty the messaging queue</span></div><div class="line">        <span class="keyword">new</span> Thread(() -&gt; {</div><div class="line">            <span class="keywordflow">while</span> (m_client.isConnected()) {</div><div class="line">                m_signal.waitForSignal();</div><div class="line">                <span class="keywordflow">try</span> {</div><div class="line">                    reader.processMsgs();</div><div class="line">                } <span class="keywordflow">catch</span> (Exception e) {</div><div class="line">                    <a class="code" href="namespaceSystem.html">System</a>.out.println(<span class="stringliteral">&quot;Exception: &quot;</span>+e.getMessage());</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }).start();</div></div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        &#39;Once the messages are in the queue, an additional thread need to fetch them</div><div class="line">        Dim msgThread As Thread = New Thread(AddressOf messageProcessing)</div><div class="line">        msgThread.IsBackground = True</div><div class="line">        If (wrapperImpl.serverVersion() &gt; 0) Then Call msgThread.Start()</div></div><!-- fragment --> ... <div class="fragment"><div class="line">    Private Sub messageProcessing()</div><div class="line">        Dim reader As EReader = New EReader(wrapperImpl.socketClient, wrapperImpl.eReaderSignal)</div><div class="line">        reader.Start()</div><div class="line">        While (wrapperImpl.socketClient.IsConnected)</div><div class="line">            wrapperImpl.eReaderSignal.waitForSignal()</div><div class="line">            reader.processMsgs()</div><div class="line">        End While</div><div class="line">    End Sub</div></div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        m_pReader = <span class="keyword">new</span> EReader(m_pClient, &amp;m_osSignal);</div><div class="line">        m_pReader-&gt;start();</div></div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        <span class="comment">#this code is in Client::connect() so it&#39;s automatically done, no need</span></div><div class="line">        <span class="comment"># for user to do it</span></div><div class="line">        self.reader = reader.EReader(self.conn, self.msg_queue)</div><div class="line">        self.reader.start()   <span class="comment"># start thread</span></div><div class="line"></div></div><!-- fragment -->  </li>
</ul>
<p>Now it is time to revisit the role of <a class="el" href="interfaceIBApi_1_1EReaderSignal.html">IBApi.EReaderSignal</a> initially introduced in <a class="el" href="client_wrapper.html#client_socket">The EClientSocket Class</a>. As mentioned in the previous paragraph, after the EReader thread places a message in the queue, a notification is issued to make known that a message is ready for processing. In the (C++, C#/.NET, Java) APIs, this is done via the <a class="el" href="interfaceIBApi_1_1EReaderSignal.html">IBApi.EReaderSignal</a> object we initiated within the <a class="el" href="interfaceIBApi_1_1EWrapper.html">IBApi.EWrapper</a>'s implementer. In the Python API, it is handled automatically by the <a href="https://docs.python.org/3/library/queue.html" target="_blank">Queue class</a>.</p>
<p>The client application is now ready to work with the Trader Workstation! At the completion of the connection, the API program will start receiving events such as <a class="el" href="interfaceIBApi_1_1EWrapper.html#a09c07727efd297e438690ab42838d332">IBApi.EWrapper.nextValidId</a> and <a class="el" href="interfaceIBApi_1_1EWrapper.html#abd7e561f313bcc4c860074906199a46c">IBApi.EWrapper.managedAccounts</a>. In TWS (<em>not IB Gateway</em>) if there is an active network connection, there will also immediately be callbacks to <a class="el" href="interfaceIBApi_1_1EWrapper.html#a7dfc221702ca65195609213c984729b8" title="Handles errors generated within the API itself. If an exception is thrown within the API code it will...">IBApi::EWrapper::error</a> with errorId as -1 and errorCode=<em>2104</em>,<em>2106</em>, errorMsg = "Market Data Server is ok" to indicate there is an active connection to the IB market data server. Callbacks to <a class="el" href="interfaceIBApi_1_1EWrapper.html#a7dfc221702ca65195609213c984729b8" title="Handles errors generated within the API itself. If an exception is thrown within the API code it will...">IBApi::EWrapper::error</a> with errorId as -1 do not represent true 'errors' but only notifications that a connection has been made successfully to the IB market data farms.</p>
<p>IB Gateway by contrast will not make connections to market data farms until a request is made by the IB client. Until this time the connection indicator in the IB Gateway GUI will show a yellow color of 'inactive' rather than an 'active' green indication.</p>
<p>When initially making requests from an API application it is important that the verifies that a response is received rather than proceeding assuming that the network connection is ok and the subscription request (portfolio updates, account information, etc) was made successfully.</p>
<h1><a class="anchor" id="accept_connections"></a>
Accepting an API connection from TWS</h1>
<p>For security reasons, by default the API is not configured to automatically accept connection requests from API applications. After a connection attempt, a dialogue will appear in TWS asking the user to manually confirm that a connection can be made:</p>
<div class="image">
<img src="conn_prompt.png" alt="conn_prompt.png"/>
</div>
<p>To prevent the TWS from asking the end user to accept the connection, it is possible to configure it to automatically accept the connection from a trusted IP address and/or the local machine. This can easily be done via the TWS API settings:</p>
<div class="image">
<img src="tws_allow_connections.png" alt="tws_allow_connections.png"/>
</div>
<p><b>Note:</b> you have to make sure the connection has been fully established before attempting to do any requests to the TWS. Failure to do so will result in the TWS closing the connection. Typically this can be done by waiting for a callback from an event and the end of the initial connection handshake, such as <a class="el" href="interfaceIBApi_1_1EWrapper.html#a09c07727efd297e438690ab42838d332">IBApi.EWrapper.nextValidId</a> or <a class="el" href="interfaceIBApi_1_1EWrapper.html#abd7e561f313bcc4c860074906199a46c">IBApi.EWrapper.managedAccounts</a>.</p>
<p>In rare cases in which IB Gateway or TWS has a momentarily delay in establishing connecting to the IB servers, messages sent immediately after receiving the nextValidId could be dropped and would need to be resent. If the API client has not receive the expected callbacks from issued requests, it should not proceed assumming the connection is ok.</p>
<h1><a class="anchor" id="broken"></a>
Broken API socket connection</h1>
<p>If there is a problem with the socket connection between TWS and the API client, for instance if TWS suddenly closes, this will trigger an exception in the EReader thread which is reading from the socket. This exception will also occur if an API client attempts to connect with a client ID that is already in use.</p>
<p>The socket EOF is handled slightly differently in different API languages. For instance in Java, it is caught and sent to the client application to <a class="el" href="interfaceIBApi_1_1EWrapper.html#a7dfc221702ca65195609213c984729b8" title="Handles errors generated within the API itself. If an exception is thrown within the API code it will...">IBApi::EWrapper::error</a> with errorCode 507: "Bad Message". In C# it is caught and sent to <a class="el" href="interfaceIBApi_1_1EWrapper.html#a7dfc221702ca65195609213c984729b8" title="Handles errors generated within the API itself. If an exception is thrown within the API code it will...">IBApi::EWrapper::error</a> with errorCode -1. The client application needs to handle this error message and use it to indicate that an exception has been thrown in the socket connection. Associated functions such as <a class="el" href="interfaceIBApi_1_1EWrapper.html#a9b0f099dc421e5a48ec290cab67a8ad1" title="Callback to indicate the API connection has closed. Following a API &lt;-&gt; TWS broken socket connection...">IBApi::EWrapper::connectionClosed</a> and <a class="el" href="classIBApi_1_1EClient.html#ab8e2702adca8f47228f9754f4963455d" title="Indicates whether the API-TWS connection has been closed. Note: This function is not automatically in...">IBApi::EClient::IsConnected</a> functions are not called automatically by the API code but need to be handled at the API client-level.</p>
<p><br />
<br />
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">This website uses cookies. By navigating through it you agree to the use of cookies. Copyright Interactive Brokers 2016 </li>
  </ul>
</div>
<!--BEGIN GCS_SEARCHBOX-->
<style type='text/css'>
	.gsc-control-cse{
		font family: Arial, sans-serif;
		border-color: #000100;
		background-color: #000000;
		width:260px;
		height: 20px;
		padding-top: 6px;
	}
	input.gsc-search-button {
		background-color: #6D1800;
		color: #fff;
		cursor: pointer;
	}
	input.gsc-search-button:hover {
		background-color: #A02200;
	}
	td.gsc-clear-button {
		position: relative;
		right: 85px;
	}
  }
</style>
<!--END GCS_SEARCHBOX-->
</body>
</html>
