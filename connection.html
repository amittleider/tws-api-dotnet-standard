<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>TWS API v9.72: Connection</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="https://www.interactivebrokers.com/favicon.ico" rel="shortcut icon">
<script>
$(document).ready(function(){
		var picked=getCookie("picked");
		if (picked != "") {
			if (!$(this).hasClass("active")) {
				var tabNum = $(this).index();
				var nthChild = picked;
				$("ul#tabs li.active").removeClass("active");
				$(this).addClass("active");
				$("ul#tab li.active").removeClass("active");
				$("ul#tab li:nth-child("+nthChild+")").addClass("active");
				$("ul#tabs li:nth-child("+nthChild+")").addClass("active");
				setCookie("picked", nthChild, 1);
			}
		}
		$("ul#tabs li").click(function(e){
			if (!$(this).hasClass("active")) {
			var tabNum = $(this).index();
			var nthChild = tabNum+1;
			$("ul#tabs li.active").removeClass("active");
			$(this).addClass("active");
			$("ul#tab li.active").removeClass("active");
			$("ul#tab li:nth-child("+nthChild+")").addClass("active");
			setCookie("picked", nthChild, 1);
		}
    });
});
function setCookie(cname, cvalue, exdays) {
    var d = new Date();
    d.setTime(d.getTime() + (exdays*24*60*60*1000));
    var expires = "expires="+d.toUTCString();
    document.cookie = cname + "=" + cvalue + "; " + expires;
} 
function getCookie(cname) {
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0)==' ') c = c.substring(1);
        if (c.indexOf(name) == 0) return c.substring(name.length,c.length);
    }
    return "";
} 
function checkCookie() {
    var picked=getCookie("picked");
    if (picked != "") {
        alert("Welcome again " + picked);
    }else{
        //username = prompt("Please enter your name:", "");
        if (picked != "" && picked != null) {
            setCookie("picked", 1, 365);
        }
    }
}
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ib_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea" style="background-color:black;">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr>
  <td id="projectlogo"><img alt="Logo" src="nav_iblogo.png"/></a></td>
  <td style="padding: 0 0 0 1em;">
   <ul id="tabs"><li class="active">C#</li><li>Java</li><li>VB</li><li>C++</li></ul>
  </td>
  <td><a href="mailto:api@interactivebrokers.com?subject=TWS API Documentation" style="color:#C7C7C7;font-weight:bold;padding: 0 0 0 1em;">Contact us</a></td>
  <!--BEGIN GCS_SEARCHBOX-->
  <td style="position: absolute; right: 0;">
   <div id="google-custom-search" align="right" style="vertical-align: top;">
   <script>
  (function() {
    var cx = '002885114636493240026:q6smajphkxq';
	var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
	</script>
	<gcse:search newWindow="false" enableHistory="true"></gcse:search>
   </div>
   </td>
  <!--END !GCS_SEARCHBOX-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('connection.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Connection </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A TCP connection between your API client application and the TWS needs to be established via the IBApi::EClient::eConnect function. The TWS can be considered like a server actively listening for incoming connection requests on a given port. Note that the TWS can accept up to <b>32 different client applications</b> simultaneously each of them identified by a unique client Id.</p>
<h1><a class="anchor" id="connect"></a>
Connecting</h1>
<p>Once our two main objects have been created, the client application can then connect via the <a class="el" href="classIBApi_1_1EClientSocket.html">IBApi.EClientSocket</a> object:</p>
<ul id="tab">
<li class="active">
<div class="fragment"><div class="line">            clientSocket.eConnect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7496, 0);</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        m_client.eConnect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7496, 0);</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        socketClient.eConnect(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, 7496, 0)</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        client.connect( host, port, clientId);</div>
</div><!-- fragment -->  </li>
</ul>
<h1><a class="anchor" id="connect_ack"></a>
Acknowledging the connection</h1>
<p>After the socket connection is established between the TWS and the client, both applications need to exchange important information such as their respective versions and in the case of the client application, its unique client Id. The API connection supports synchronous and asynchronous connection requests. When the client application decides to connect asynchronously, it will have to wait for an acknowledgment from the TWS before attempting to send the information described at the beginning of this paragraph. This acknowledgment is received via the <a class="el" href="interfaceIBApi_1_1EWrapper.html#af9a662ffc740646d319356f65725f15f">IBApi.EWrapper.connectAck</a> method. When this event is triggered within an asynchronous context, the client application will have to start the flow of information to the TWS via the <a class="el" href="classIBApi_1_1EClient.html#acf1370a40894c7a3d44053142077397b">IBApi.EClientSocket.startApi</a> method.</p>
<ul id="tab">
<li class="active">
<div class="fragment"><div class="line">    <span class="keyword">public</span> <span class="keyword">class </span>EWrapperImpl : EWrapper </div>
<div class="line">    {</div>
</div><!-- fragment --> ... <div class="fragment"><div class="line">        <span class="keyword">public</span> <span class="keywordtype">void</span> connectAck()</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (ClientSocket.AsyncEConnect)</div>
<div class="line">                ClientSocket.startApi();</div>
<div class="line">        }</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>EWrapperImpl <span class="keyword">implements</span> EWrapper {</div>
</div><!-- fragment --> ... <div class="fragment"><div class="line">    @Override</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> connectAck() {</div>
<div class="line">        <span class="keywordflow">if</span> (clientSocket.isAsyncEConnect()) {</div>
<div class="line">            System.out.println(<span class="stringliteral">&quot;Acknowledging connection&quot;</span>);</div>
<div class="line">            clientSocket.startAPI();</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        Public Sub connectAck() Implements IBApi.EWrapper.connectAck</div>
<div class="line">            Console.WriteLine(&quot;ConnectAck&quot;)</div>
<div class="line">            If socketClient.AsyncEConnect Then</div>
<div class="line">                socketClient.startApi()</div>
<div class="line">            End If</div>
<div class="line">        End Sub</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line"><span class="keyword">class </span>TestCppClient : <span class="keyword">public</span> EWrapper</div>
<div class="line">{</div>
</div><!-- fragment --> ... <div class="fragment"><div class="line"><span class="keywordtype">void</span> TestCppClient::connectAck() {</div>
<div class="line">    <span class="keywordflow">if</span> (!m_extraAuth &amp;&amp; m_pClient-&gt;asyncEConnect())</div>
<div class="line">        m_pClient-&gt;startApi();</div>
<div class="line">}</div>
</div><!-- fragment -->  </li>
</ul>
<p>Note: all our sample code connects synchronously to the TWS.</p>
<h1><a class="anchor" id="ereader"></a>
Consuming TWS data</h1>
<p>The final step on this procedure is to consume the incoming data within a separate execution thread. The class in charge of reading and parsing the raw messages from the TWS is the <a class="el" href="classIBApi_1_1EReader.html">IBApi.EReader</a> class. Internally, whenever there are messages ready to be consumed by the EReader object, a signal will be issued to this reading thread indicating so. The process is better illustrated through an example:</p>
<ul id="tab">
<li class="active">
<div class="fragment"><div class="line">            <span class="comment">//Create a reader to consume messages from the TWS. The EReader will consume the incoming messages and put them in a queue</span></div>
<div class="line">            var reader = <span class="keyword">new</span> EReader(clientSocket, readerSignal);</div>
<div class="line">            reader.Start();</div>
<div class="line">            <span class="comment">//Once the messages are in the queue, an additional thread need to fetch them</span></div>
<div class="line">            <span class="keyword">new</span> Thread(() =&gt; { <span class="keywordflow">while</span> (clientSocket.IsConnected()) { readerSignal.waitForSignal(); reader.processMsgs(); } }) { IsBackground = <span class="keyword">true</span> }.Start();</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        <span class="keyword">final</span> EReader reader = <span class="keyword">new</span> EReader(m_client, m_signal);        </div>
<div class="line">        reader.start();        </div>
<div class="line">        <span class="keyword">new</span> Thread() {</div>
<div class="line">            <span class="keyword">public</span> <span class="keywordtype">void</span> run() {</div>
<div class="line">                <span class="keywordflow">while</span> (m_client.isConnected()) {</div>
<div class="line">                    m_signal.waitForSignal();</div>
<div class="line">                    <span class="keywordflow">try</span> {</div>
<div class="line">                        reader.processMsgs();</div>
<div class="line">                    } <span class="keywordflow">catch</span> (Exception e) {</div>
<div class="line">                        System.out.println(<span class="stringliteral">&quot;Exception: &quot;</span>+e.getMessage());</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }.start();</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        <span class="stringliteral">&#39;Once the messages are in the queue, an additional thread need to fetch them</span></div>
<div class="line"><span class="stringliteral">        Dim msgThread As Thread = New Thread(AddressOf messageProcessing)</span></div>
<div class="line"><span class="stringliteral">        msgThread.IsBackground = True</span></div>
<div class="line"><span class="stringliteral">        If (wrapperImpl.serverVersion() &gt; 0) Then Call msgThread.Start()</span></div>
</div><!-- fragment --> ... <div class="fragment"><div class="line">    Private Sub messageProcessing()</div>
<div class="line">        Dim reader As EReader = New EReader(wrapperImpl.socketClient, wrapperImpl.eReaderSignal)</div>
<div class="line">        reader.Start()</div>
<div class="line">        While (wrapperImpl.socketClient.IsConnected)</div>
<div class="line">            wrapperImpl.eReaderSignal.waitForSignal()</div>
<div class="line">            reader.processMsgs()</div>
<div class="line">        End While</div>
<div class="line">    End Sub</div>
</div><!-- fragment -->  </li>
<li>
<div class="fragment"><div class="line">        <span class="comment">//Unlike the C# and Java clients, there is no need to explicitely create an EReader object nor a thread</span></div>
<div class="line">        <span class="keywordflow">while</span>( client.isConnected()) {</div>
<div class="line">            client.processMessages();</div>
<div class="line">        }</div>
</div><!-- fragment -->  </li>
</ul>
<p>Now it is time to revisit the role of <a class="el" href="interfaceIBApi_1_1EReaderSignal.html">IBApi.EReaderSignal</a> initially introduced in <a class="el" href="client_wrapper.html#client_socket">The EClientSocket class</a>. As mentioned in the previous paragraph, the EReader's thread will need to be notified whenever there is information ready to be consumed. This is done via the <a class="el" href="interfaceIBApi_1_1EReaderSignal.html">IBApi.EReaderSignal</a> object we initiated within the <a class="el" href="interfaceIBApi_1_1EWrapper.html">IBApi.EWrapper</a>'s implementor.</p>
<p>The client application is now ready to work with the Trader Workstation! As soon as the connection has been fully established, you will immediately start receiving events from the TWS such as <a class="el" href="interfaceIBApi_1_1EWrapper.html#a09c07727efd297e438690ab42838d332">IBApi.EWrapper.nextValidId</a> or <a class="el" href="interfaceIBApi_1_1EWrapper.html#abd7e561f313bcc4c860074906199a46c">IBApi.EWrapper.managedAccounts</a></p>
<h1><a class="anchor" id="accept_connections"></a>
Accepting the connection on the TWS side.</h1>
<p>To prevent unwanted connections by default, the TWS is not configured to automatically accept any incoming connection request. Whenever a client application tries to connect to the TWS and the TWS is not configured to accept incoming connection requests from the host the client application is in, a prompt window will appear requiring the user to accept the connection attempt:</p>
<div class="image">
<img src="conn_prompt.png" alt="conn_prompt.png"/>
</div>
<p>To prevent the TWS from asking the end user to accept the connection, it is possible to configure it to automatically accept the connection from a trusted IP address and/or the local machine. This can easily be done via the TWS API settings:</p>
<div class="image">
<img src="tws_allow_connections.png" alt="tws_allow_connections.png"/>
</div>
<p><b>Note:</b> you have to make sure the connection has been fully established before attempting to do any requests to the TWS. Failure to do so will result in the TWS closing the connection. The safest way to prevent this situation is simply to wait until one of <a class="el" href="interfaceIBApi_1_1EWrapper.html#a09c07727efd297e438690ab42838d332">IBApi.EWrapper.nextValidId</a> or <a class="el" href="interfaceIBApi_1_1EWrapper.html#abd7e561f313bcc4c860074906199a46c">IBApi.EWrapper.managedAccounts</a> events is triggered before attempting to request anything from the TWS.</p>
<p><br/>
<br/>
 </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">This website uses cookies. By navigating through it you agree to the use of cookies. Copyright Interactive Brokers 2016 </li>
  </ul>
</div>
<!--BEGIN GCS_SEARCHBOX-->
<style type='text/css'>
	.gsc-control-cse{
		font family: Arial, sans-serif;
		border-color: #000100;
		background-color: #000000;
		width:250px;
		height: 20px;
		padding-top: 6px;
	}
	input.gsc-search-button {
		background-color: #6D1800;
		color: #fff;
		cursor: pointer;
	}
	input.gsc-search-button:hover {
		background-color: #A02200;
	}
	td.gsc-clear-button {
		position: relative;
		right: 85px;
	}
  }
</style>
<!--END GCS_SEARCHBOX-->
</body>
</html>
