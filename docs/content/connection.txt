/*! \page connection Connection

	A TCP connection between the API client application and TWS needs to first be established via the @ref IBApi::EClientSocket::eConnect function. TWS acts as a server to receive requests from the API application (the client) and responds by taking appropriate actions. The first step is for the API client to initiate a connection to the socket port on which TWS is listening. It is possible to have multiple TWS instances running on the same computer if each is configured with a different API socket port number. Also, each TWS session can receive up to <b>32 different client applications</b> simultaneously. The <b>client ID</b> field specified in the API connection is used to distinguish different API clients.
		
	\section connect Establishing an API connection
	
	Once our two main objects have been created, EWrapper and ESocketClient, the client application can connect via the @ref IBApi::EClientSocket object:
	
	<ul id="tab">
		<li class="active"> 
		\snippet Program.cs connect
		</li>
		<li>
		\snippet Testbed.java connect
		</li>
		<li>
		\snippet MainModule.vb connect
		</li>
		<li>
		\snippet TestCppClient.cpp connect
		</li>
		<li>
		\snippet Program.py connect
		</li>
	</ul>
	
	eConnect starts by requesting from the OS that a TCP socket be opened to the specified IP address and host number- the first two parameters in the function call. If the socket cannot be opened, the OS returns an error condition which the API returns as error code 502 to IBApi.EWrapper.error. Since this error is not generated by TWS it is not captured in TWS log files. Most commonly error 502 will indicate that TWS is not running with the API enabled or is listening for connection requests on a different socket port. If connecting across a network, it can also occur if there is a firewall or antivirus program blocking connections. 
	
	After the socket has been opened, both applications need to exchange essential information for the API session. First, the version numbers of the client (API program) and server (TWS) are exchanged so that the server and client each know the function calls supported by one another. In this way backwards compatibility can be maintained between TWS and previous API versions. Next TWS will always return certain information for the client session, namely the accounts which are accessible by the TWS session, the next valid order identifier (ID), and the time of connection. In the most common mode of operation the EClient.AsyncEConnect field is set to false and the initial handshake is taken to completion immediately after the socket connection is established. TWS will then immediately provides the API client with this information.
	
	- Important: The <b>IBApi.EWrapper.nextValidID</b> callback is commonly used to indicate that the connection is completed and other messages can be sent from the API client to TWS. There is the possibility that function calls made prior to this time could be dropped by TWS.
	
	There is also an alternative mode of connection used in special cases in wich the variable AsyncEconnect is set to true, and the call to startAPI is only called from the connectAck() function. All IB samples use the mode AsyncEconnect = False.
	
	\section ereader The EReader Thread
	
	API programs always have at least two threads of execution. One thread is used for sending messages to TWS, and another thread is used for reading returned messages. The second thread uses the API EReader class to read from the socket and add messages to a queue. Everytime a new message is added to the message queue, a notification flag is triggered to let other threads now that there is a message waiting to be processed. In the two-thread design of an API program, the message queue is also processed by the first thread. In a three-thread design, an additional thread is created to perform this task. The thread responsible for the message queue will decode messages and invoke the appropriate functions in EWrapper. The two-threaded design is used in the IB Python sample Program.py and the C++ sample TestCppClient, while the 'Testbed' samples in the other languages use a three-threaded design. Commonly in a Python asynchronous network application, the <a href="https://docs.python.org/3/library/asyncio.ht" target="_blank">asyncio module</a> will be used to create a more sequential looking code design.
	
	The class which has functionality for reading and parsing raw messages from TWS is the @ref IBApi::EReader class.
	
	<ul id="tab">
		<li class="active"> 
		\snippet Program.cs ereader
		</li>
		<li>
		\snippet Testbed.java ereader
		</li>
		<li> 
		\snippet MainModule.vb ereader
		...
		\snippet MainModule.vb ereader_thread
		</li>
		<li>
		\snippet TestCppClient.cpp ereader
		</li>
		<li> 
		\snippet Program.py ereader
		</li>
	</ul>
	
	Now it is time to revisit the role of @ref IBApi::EReaderSignal initially introduced in @ref client_socket. As mentioned in the previous paragraph, after the EReader thread places a message in the queue, a notification is issued to make known that a message is ready for processing. In the (C++, C#/.NET, Java) APIs, this is done via the @ref IBApi::EReaderSignal object we initiated within the @ref IBApi::EWrapper's implementer. In the Python API, it is handled automatically by the <a href="https://docs.python.org/3/library/queue.html" target="_blank">Queue class</a>.

	The client application is now ready to work with the Trader Workstation! At the completion of the connection, the API program will start receiving events such as @ref IBApi::EWrapper::nextValidId and @ref IBApi::EWrapper::managedAccounts. In TWS (<i>not IB Gateway</i>) if there is an active network connection, there will also immediately be callbacks to IBApi::EWrapper::error with errorId as -1 and errorCode=<i>2104</i>,<i>2106</i>, errorMsg = "Market Data Server is ok" to indicate there is an active connection to the IB market data server. Callbacks to IBApi::EWrapper::error with errorId as -1 do not represent true 'errors' but only notifications that a connection has been made successfully to the IB market data farms. 
	
	IB Gateway by contrast will not make connections to market data farms until a request is made by the IB client. Until this time the connection indicator in the IB Gateway GUI will show a yellow color of 'inactive' rather than an 'active' green indication. 
	
	When initially making requests from an API application it is important that the verifies that a response is received rather than proceeding assuming that the network connection is ok and the subscription request (portfolio updates, account information, etc) was made successfully. 
	
	\section accept_connections Accepting an API connection from TWS
	
	For security reasons, by default the API is not configured to automatically accept connection requests from API applications. After a connection attempt, a dialogue will appear in TWS asking the user to manually confirm that a connection can be made: 
	
	\image html conn_prompt.png
	
	To prevent the TWS from asking the end user to accept the connection, it is possible to configure it to automatically accept the connection from a trusted IP address
	and/or the local machine. This can easily be done via the TWS API settings:
	
	\image html tws_allow_connections.png
	
	<b>Note:</b> you have to make sure the connection has been fully established before attempting to do any requests to the TWS. Failure to do so will result in the TWS
	closing the connection. Typically this can be done by waiting for a callback from an event and the end of the initial connection handshake, such as @ref IBApi::EWrapper::nextValidId or @ref IBApi::EWrapper::managedAccounts. 
	
	In rare cases in which IB Gateway or TWS has a momentarily delay in establishing connecting to the IB servers, messages sent immediately after receiving the nextValidId could be dropped and would need to be resent. If the API client has not receive the expected callbacks from issued requests, it should not proceed assumming the connection is ok. 
	
	\section broken Broken API socket connection
	
	If there is a problem with the socket connection between TWS and the API client, for instance if TWS suddenly closes, this will trigger an exception in the EReader thread which is reading from the socket. This exception will also occur if an API client attempts to connect with a client ID that is already in use. 
	
	The socket EOF is handled slightly differently in different API languages. For instance in Java, it is caught and sent to the client application to IBApi::EWrapper::error with errorCode 507: "Bad Message". In C# it is caught and sent to IBApi::EWrapper::error with errorCode -1. The client application needs to handle this error message and use it to indicate that an exception has been thrown in the socket connection. Associated functions such as IBApi::EWrapper::connectionClosed and IBApi::EClient::IsConnected functions are not called automatically by the API code but need to be handled at the API client-level.
	
	<br><br>

*/